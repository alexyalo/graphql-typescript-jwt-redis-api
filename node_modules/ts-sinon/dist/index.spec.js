"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai = require("chai");
var sinonChai = require("sinon-chai");
var index_1 = require("./index");
chai.use(sinonChai);
var expect = chai.expect;
describe('ts-sinon', function () {
    describe('stubObject', function () {
        it('returns stub es6 object with all methods stubbed when no methods or method map given', function () {
            var object = new /** @class */ (function () {
                function class_1() {
                }
                class_1.prototype.test = function () {
                    return 123;
                };
                class_1.prototype.run = function () {
                    return 'run';
                };
                return class_1;
            }());
            var objectStub = index_1.stubObject(object);
            expect(object.test()).to.equal(123);
            expect(object.run()).to.equal('run');
            expect(objectStub.test()).to.be.undefined;
            expect(objectStub.run()).to.be.undefined;
            expect(objectStub.run).to.have.been.called;
            expect(objectStub.test).to.have.been.called;
        });
        it('returns stub literal object with all methods stubbed when no methods or method map given', function () {
            var object = {
                test: function () {
                    return 123;
                },
                run: function () {
                    return 'run';
                }
            };
            var objectStub = index_1.stubObject(object);
            expect(object.test()).to.equal(123);
            expect(object.run()).to.equal('run');
            expect(objectStub.test()).to.be.undefined;
            expect(objectStub.run()).to.be.undefined;
            expect(objectStub.run).to.have.been.called;
            expect(objectStub.test).to.have.been.called;
        });
        it('returns partial stub object with only "test" method stubbed when array with "test" has been given', function () {
            var object = new /** @class */ (function () {
                function class_2() {
                    this.r = 'run';
                }
                class_2.prototype.test = function () {
                    return 123;
                };
                class_2.prototype.run = function () {
                    return this.r;
                };
                return class_2;
            }());
            var objectStub = index_1.stubObject(object, ['test']);
            expect(objectStub.test()).to.be.undefined;
            expect(objectStub.run()).to.equal('run');
            expect(objectStub.test).to.have.been.called;
        });
        it('returns partial stub object with "run" method stubbed and returning "1" value when key value map { run: 1 } has been given', function () {
            var object = new /** @class */ (function () {
                function class_3() {
                }
                class_3.prototype.test = function () {
                    return 123;
                };
                class_3.prototype.run = function () {
                    return 'run';
                };
                return class_3;
            }());
            var objectStub = index_1.stubObject(object, { 'run': 1 });
            expect(objectStub.run()).to.equal(1);
            expect(objectStub.test()).to.equal(123);
            expect(objectStub.run).to.have.been.called;
        });
    });
    describe('stubInterface', function () {
        it('returns stub object created from interface with all methods stubbed with "method2" predefined to return value of "abc" and "method1" which is testable with expect that has been called', function () {
            var expectedMethod2Arg = 2;
            var expectedMethod2ReturnValue = 'abc';
            var interfaceStub = index_1.stubInterface({
                method2: expectedMethod2ReturnValue
            });
            var object = new /** @class */ (function () {
                function class_4(test) {
                    this.test = test;
                    this.test.method1();
                }
                class_4.prototype.run = function (num) {
                    return this.test.method2(num);
                };
                return class_4;
            }())(interfaceStub);
            expect(object.run(expectedMethod2Arg)).to.equal(expectedMethod2ReturnValue);
            expect(interfaceStub.method1).to.have.been.called;
            expect(interfaceStub.method2).to.have.been.calledWith(expectedMethod2Arg);
        });
        it('returns stub object created from interface with all methods stubbed including "method2" predefined to return "x" when method map to value { method: x } has been given', function () {
            var interfaceStub = index_1.stubInterface({
                method2: 'test'
            });
            var object = new /** @class */ (function () {
                function class_5(test) {
                    this.test = test;
                    this.test.method1();
                }
                class_5.prototype.run = function (num) {
                    return this.test.method2(num);
                };
                return class_5;
            }())(interfaceStub);
            expect(object.run(123)).to.equal('test');
        });
        it('gives an access to method stubs of the stub object created from interface when the type of the interface type is cast to "any" and the ability to stub and test interface methods', function () {
            var expectedMethod2Arg = 2;
            var interfaceStub = index_1.stubInterface();
            interfaceStub.method2.returns('string');
            var object = new /** @class */ (function () {
                function class_6(test) {
                    this.test = test;
                    this.test.method1();
                }
                class_6.prototype.run = function (num) {
                    return this.test.method2(num);
                };
                return class_6;
            }())(interfaceStub);
            expect(object.run(expectedMethod2Arg)).to.equal('string');
            expect(interfaceStub.method1).to.have.been.called;
            expect(interfaceStub.method2).to.have.been.calledWith(expectedMethod2Arg);
        });
    });
});
